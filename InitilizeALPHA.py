#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Dec 15 16:16:04 2020

@author: boraulu
"""

import numpy as np
from itertools import permutations, combinations, chain
import time
from scipy.sparse import coo_matrix, csc_matrix, csr_matrix
from cvxopt import matrix, solvers, sparse, spmatrix
import mosek
from numba import njit
import functools 
import copy
from igraph import *

@njit
def Is_vec_in_mat(vec,mat):
    assume=True
    for elem in mat:
        if np.array_equal(vec, elem):
            assume=False
            break
    return assume


@njit
def dimino_wolfe(group_generators):
        gens=group_generators
        degree=np.max(gens)+1
        idn = np.arange(degree)
        order = 0
        element_list = [idn]
        #element_list=np.atleast_2d(idn)
        #set_element_list = {tuple(idn)}
        for i in np.arange(len(gens)):
            # D elements of the subgroup G_i generated by gens[:i]
            D = element_list[:]
            N = [idn]
            while N:
                A = N
                N = []
                for a in A:
                    for g in gens[:i + 1]:
                        ag = a[g]
                        if Is_vec_in_mat(ag,element_list):
                        #if not np.any(np.all(ag==np.array(element_list,np.int64),axis=1)):
                        #if ag not in np.array(element_list):
                        #if tuple(ag) not in set_element_list:
                            # produce G_i*g
                            for d in D:
                                order += 1
                                ap = d[ag]
                                element_list.append(ap)
                                #element_list=np.append(element_list, np.atleast_2d(ap), axis=0)
                                #set_element_list.add(tuple(ap))
                                N.append(ap)
        return element_list

def Deduplicate(ar): #Alternatives include unique_everseen and panda.unique, see https://stackoverflow.com/a/15637512 and https://stackoverflow.com/a/41577279
    (vals,idx)=np.unique(ar,return_index=True)
    return vals[np.argsort(idx)]

@njit
def MoveToFront(num_var,ar):
    return np.hstack((ar,np.delete(np.arange(num_var),ar)))

@njit
def MoveToBack(num_var,ar):
    return np.hstack((np.delete(np.arange(num_var),ar),ar))

def ToTopologicalOrdering(g):
    return g.permute_vertices(np.argsort(g.topological_sorting('out')).tolist())

def LearnParametersFromGraph(origgraph):
    g=ToTopologicalOrdering(origgraph)
    verts=g.vs
    verts["parents"]=g.get_adjlist('in');
    verts["children"]=g.get_adjlist('out');
    verts["ancestors"]=[g.subcomponent(i,'in') for i in g.vs]
    verts["descendants"]=[g.subcomponent(i,'out') for i in g.vs]
    verts["indegree"]=g.indegree()
    verts["outdegree"]=g.outdegree() #Not needed
    verts["grandparents"]=g.neighborhood(None, order=2, mode='in', mindist=2)
    verts["parents_inclusive"]=g.neighborhood(None, order=1, mode='in', mindist=0) #Not needed
    has_grandparents=[idx for idx,v in enumerate(g.vs["grandparents"]) if len(v)>=1]
    verts["isroot"]=[0==i for i in g.vs["indegree"]]
    root_vertices=verts.select(isroot = True).indices
    nonroot_vertices=verts.select(isroot = False).indices
    verts["roots_of"]=[np.intersect1d(anc,root_vertices).tolist() for anc in g.vs["ancestors"]]
    def FindScreeningOffSet(root,observed):
        screeningset=np.intersect1d(root["descendants"],observed["parents"]).tolist()
        screeningset.append(observed.index)
        return screeningset
    determinism_checks=[(root,FindScreeningOffSet(verts[root],v)) for v in g.vs[has_grandparents] for root in np.setdiff1d(v["roots_of"],v["parents"])]
    return verts["name"],verts["parents"],verts["roots_of"],determinism_checks

inflation_order=2
card=4
g=Graph.Formula("X->A,Y->A:B,X->C,Z->B:C")
#g=Graph.Formula("U1->A,U2->B:C,U1->D,A->B,B->C:D")


names,parents_of,roots_of,determinism_checks = LearnParametersFromGraph(g)
graph_structure=list(filter(None,parents_of))
obs_count=len(graph_structure)
latent_count=len(parents_of)-obs_count
root_structure=roots_of[latent_count:]

inflation_depths=np.array(list(map(len,root_structure)))
inflationcopies=inflation_order**inflation_depths
num_vars=inflationcopies.sum()

accumulated=np.add.accumulate(inflationcopies)
offsets = np.hstack(([0],accumulated[:-1]))
cannonical_pos=np.zeros((obs_count,inflation_order),dtype=np.uint32)
for i in range(obs_count):
    
    depth=inflation_depths[i]
    number_of_copies=inflation_order**depth
    step=int(np.floor((number_of_copies)/(inflation_order-1)))
    if step == number_of_copies:
        step=step-1
    cannonical_pos[i]=np.arange(0,number_of_copies,step)
    
exp_set=np.ravel(cannonical_pos.T+offsets)
    
#print(exp_set) 



globalstrategyflat=list(np.add(*stuff) for stuff in zip(list(map(np.arange,inflationcopies.tolist())),offsets))

reshapings=np.ones((obs_count,latent_count),np.uint8)

for idx,elem in enumerate(root_structure):
    reshapings[idx][elem]=inflation_order
reshapings=list(map(tuple,reshapings))

globalstrategyshaped=list(np.reshape(*stuff) for stuff in zip(globalstrategyflat,reshapings))

fullshape=tuple(np.full(latent_count,inflation_order))

if inflation_order==2:
    inflation_order_gen_count=1
else:
    inflation_order_gen_count=2

group_generators=np.zeros((latent_count,inflation_order_gen_count,num_vars),np.uint)
for latent_to_explore in np.arange(latent_count):
    for gen_idx in np.arange(inflation_order_gen_count):
        initialtranspose=MoveToFront(latent_count,np.array([latent_to_explore]))
        
        inversetranspose=np.hstack((np.array([0]),1+np.argsort(initialtranspose)))
        label_permutation=np.arange(inflation_order)
        if gen_idx==0:
            label_permutation[np.array([0,1])]=np.array([1,0])
        elif gen_idx==1:
            label_permutation=np.roll(label_permutation, 1)
        global_permutation=np.array(list(np.broadcast_to(elem,fullshape).transpose(tuple(initialtranspose))[label_permutation] for elem in globalstrategyshaped))
        
        #global_permutation=[]
        #for i in range(len(globalstrategyshaped)):
            
        #    elem=globalstrategyshaped[i]
        #    bgs=np.broadcast_to(elem,fullshape)
        #    bgs=bgs.transpose(tuple(initialtranspose))
        #    bgs=bgs[label_permutation]
            
        #     global_permutation.append(bgs)
            
        #global_permutation=np.array(global_permutation)
        
        global_permutation=np.transpose(global_permutation,tuple(inversetranspose))
        #print(np.ravel(global_permutation))

        global_permutation=Deduplicate(np.ravel(global_permutation))
        #print(global_permutation)
        group_generators[latent_to_explore,gen_idx]=global_permutation

"""
a=group_generators[0][0][[8,9,10,11]]
b=group_generators[2][0][[8,9,10,11]]

group_generators[0][0][[8,9,10,11]]=b
group_generators[2][0][[8,9,10,11]]=a
"""

print(group_generators)
one_generator_per_root=group_generators[:,0]

det_assumptions=list();
for pair in determinism_checks:
    flatset=exp_set[list(np.array(pair[1])-latent_count)]
    symop=one_generator_per_root[pair[0]]
    rule=np.vstack((flatset,symop[flatset])).T.astype('uint32')
    rule=rule[:-1,:].T.tolist()+rule[-1,:].T.tolist()
    det_assumptions.append(rule)

group_elem=dimino_wolfe(group_generators.reshape((-1,num_vars)))
print(np.array(group_elem))

@njit
def GenShapedColumnIntegers(range_shape):    #range_shape is presumed to be given as nparray input.
    return np.arange(0,np.prod(np.array(range_shape)),1,np.int32).reshape(range_shape)

def MarkInvalidStrategies(card,num_var,det_assumptions):
    initialshape=np.full(num_var,card,np.uint8)
    ColumnIntegers=GenShapedColumnIntegers(tuple(initialshape))
    for detrule in det_assumptions:
        initialtranspose=MoveToFront(num_var,np.hstack(tuple(detrule)))
        inversetranspose=np.argsort(initialtranspose)
        parentsdimension=card**len(detrule[1])
        intermediateshape=(parentsdimension,parentsdimension,card,card,-1);
        ColumnIntegers=ColumnIntegers.transpose(tuple(initialtranspose)).reshape(intermediateshape)
        for i in np.arange(parentsdimension):
            for j in np.arange(card-1):
                for k in np.arange(j+1,card):
                    ColumnIntegers[i,i,j,k]=-1
        ColumnIntegers=ColumnIntegers.reshape(initialshape).transpose(tuple(inversetranspose))
    return ColumnIntegers

def ValidColumnOrbits(card, num_var, group_elem,det_assumptions=[]):
    ColumnIntegers=MarkInvalidStrategies(card,num_var,det_assumptions)
    group_elements=group_elem#GroupElementsFromGenerators(GroupGeneratorsFromSwaps(num_var,anc_con))
    group_order=len(group_elements)
    AMatrix=np.empty([group_order,card**num_var],np.int32)
    AMatrix[0]=ColumnIntegers.flat #Assuming first group element is the identity
    for i in np.arange(1,group_order):
        AMatrix[i]=np.transpose(ColumnIntegers,group_elements[i]).flat
    minima=np.amin(AMatrix,axis=0)
    AMatrix=np.compress(minima==np.abs(AMatrix[0]), AMatrix, axis=1)
    print(AMatrix.shape)
    return AMatrix

def PositionIndex(arraywithduplicates):
    arraycopy=np.empty_like(arraywithduplicates)
    u=np.unique(arraywithduplicates)
    arraycopy[u]=np.arange(len(u))
    return arraycopy[arraywithduplicates]

@functools.lru_cache(maxsize=16)
def GenerateEncodingMonomialToRow(original_cardinality_product,inflation_order): #I should make this recursive, as called by both A and b construction.
    monomial_count=int(original_cardinality_product**inflation_order)
    permutation_count=int(np.math.factorial(inflation_order))
    MonomialIntegers=np.arange(0,monomial_count,1,np.uint)
    new_shape=np.full(inflation_order,original_cardinality_product)
    MonomialIntegersPermutations=np.empty([permutation_count,monomial_count],np.uint)
    IndexPermutations=list(permutations(np.arange(inflation_order)))
    MonomialIntegersPermutations[0]=MonomialIntegers
    MonomialIntegers=MonomialIntegers.reshape(new_shape)
    for i in np.arange(1,permutation_count):
        MonomialIntegersPermutations[i]=np.transpose(MonomialIntegers,IndexPermutations[i]).flat
    return PositionIndex(np.amin(
        MonomialIntegersPermutations,axis=0))

def GenerateEncodingColumnToMonomial(card,num_var,expr_set):
    initialshape=np.full(num_var,card,np.uint)
    ColumnIntegers=GenShapedColumnIntegers(tuple(initialshape))
    ColumnIntegers=ColumnIntegers.transpose(MoveToBack(num_var,np.array(expr_set))).reshape((-1,card**len(expr_set)))
    EncodingColumnToMonomial=np.empty(card**num_var,np.uint32)
    EncodingColumnToMonomial[ColumnIntegers]=np.arange(card**len(expr_set))
    return EncodingColumnToMonomial

def MergeMonomials(bvector,encoding):
    return np.ravel(coo_matrix((bvector, (np.zeros(len(bvector),np.uint8), encoding)),(1, int(np.amax(encoding)+1))).toarray())

def EncodeA(card, num_var, group_elem, expr_set, inflation_order):
    original_product_cardinality=(card**np.rint(len(expr_set)/inflation_order)).astype(np.uint)
    EncodingMonomialToRow=GenerateEncodingMonomialToRow(original_product_cardinality,inflation_order)
    EncodingColumnToMonomial=GenerateEncodingColumnToMonomial(card,num_var,np.array(expr_set))
    return EncodingMonomialToRow[EncodingColumnToMonomial][ValidColumnOrbits(card, num_var, group_elem,det_assumptions)]

def FindB(Data, inflation_order):
    EncodingMonomialToRow=GenerateEncodingMonomialToRow(len(Data),inflation_order)
    preb=np.array(Data)
    b=preb
    for i in range(1,inflation_order):
        b=np.kron(preb,b)
    b=MergeMonomials(b,EncodingMonomialToRow)
    return b

def FormCVXOPTArrayFromOnesPositions(OnesPositions):
    columncount=OnesPositions.shape[-1]
    columnspec=np.broadcast_to(np.arange(columncount), (len(OnesPositions), columncount)).ravel()
    return spmatrix(np.ones(OnesPositions.size), OnesPositions.ravel().tolist(), columnspec.tolist(),(int(np.amax(OnesPositions)+1), columncount))

def InflationLP(EncodedA,b):
    MCVXOPT=FormCVXOPTArrayFromOnesPositions(EncodedA).T
    rowcount=MCVXOPT.size[0];
    colcount=MCVXOPT.size[1];
    CVXOPTb=matrix(np.atleast_2d(b).T)
    CVXOPTh=matrix(np.zeros((rowcount,1)))
    CVXOPTA=matrix(np.ones((1,colcount)))
    return solvers.lp(CVXOPTb,-MCVXOPT,CVXOPTh,CVXOPTA,matrix(np.ones((1,1))),solver='mosek')

Data=[0.12199995751046305, 0.0022969343799089472, 0.001748319476328954, 3.999015242496535e-05, 0.028907881434196828, 0.0005736087488455967, 0.0003924033706699725, 1.1247230369521505e-05, 0.0030142577390317635, 0.09234476010282468, 4.373922921480586e-05, 0.0014533921021948346, 0.0007798079722868244, 0.024091567451515063, 1.1247230369521505e-05, 0.0003849052170902915, 0.020774884184769502, 0.000396152447459813, 0.0003049249122403608, 4.998769053120669e-06, 0.10820335492385, 0.0020794879260981982, 0.0015546171755205281, 2.4993845265603346e-05, 0.0006260958239033638, 0.020273757587194154, 7.498153579681003e-06, 0.0003374169110856452, 0.0028942872817568676, 0.08976414557915113, 2.624353752888351e-05, 0.0012984302615480939, 0.002370666223442477, 4.7488306004646356e-05, 0.0999928767540993, 0.001957018084296742, 0.0006198473625869629, 8.747845842961171e-06, 0.02636975644747481, 0.0005198719815245496, 1.4996307159362007e-05, 0.000403650601039494, 0.0005498645958432735, 0.017359475229224805, 7.123245900696953e-05, 0.002346922070440154, 0.0033754188031197316, 0.10295964618712641, 0.00038740460161685187, 7.498153579681003e-06, 0.01608353942841575, 0.000306174604503641, 0.0021319750011559654, 4.248953695152569e-05, 0.09107007399427891, 0.001860791780024169, 5.998522863744803e-05, 0.0018395470115484063, 0.002570616985567304, 0.0766411271224461, 1.874538394920251e-05, 0.00048238121362614454, 0.0006410921310627258, 0.020223769896662948]

start = time.time()
EncodedA = EncodeA(card, num_vars, group_elem, exp_set, inflation_order)
print('It took', time.time()-start, 'seconds.')
print(EncodedA.shape)

start = time.time()
b=FindB(Data,inflation_order)
MCVXOPT=FormCVXOPTArrayFromOnesPositions(EncodedA).T 
print('It took', time.time()-start, 'seconds.')
print(MCVXOPT.size)

solverout=InflationLP(EncodedA,b)


